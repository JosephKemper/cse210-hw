<p>Joseph D. Kemper</p>
<p>CSE 210-09: Programming with Classes</p>
<p>W14 Prove: Articulate</p>
<p>31 March 2023</p>
<p></p>
<p>Foundation 4 Articulate</p>
<p></p>
<p>Abstraction</p>
<p></p>
<p>
To me, abstraction is the planning part of programming. Abstraction involves taking a complex idea, simplifying it down to its most basic elements, and then using that to help you plan out how you will build your program. For me, one of the most valuable parts of abstraction is the process of asking what is the purpose of this program, and then asking the same question about each class, and even possibly asking the same question about each method you are writing. From there, you take and record the inputs that structure will take, and then the outputs it will return, and add all of that as a comment to your code to help you remember what your goal is. Here is one example of how that might look.
</p>
<code>
    Purpose
        Build the core of each exercise that will be shared by all three activity types
    Inputs
        File containing raw activity data
    Outputs
        The needed data for each class to run
</code>
<p></p>
<p>
One of the biggest benefits of abstraction I have found is that it helps you get a clearer idea of what your goals are and how you plan on getting there, and abstraction does not have to be reserved for just that time before you start writing your code. When you are stuck, stepping back and taking another high level look at both your code and where you want to go, can be extremely beneficial. 
</p>
<p></p>
<p>Encapsulation</p>
<p></p>
<p>

</p>
<p></p>
<p>Inheritance</p>
<p></p>
<p>

</p>
<p></p>
<p>Polymorphism</p>
<p></p>
<p>

</p>
<p></p>
<code>

</code>
